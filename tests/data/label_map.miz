registration
  cluster CONF -> CR for ARS;
  coherence
  proof let X;
    assume
A1: X is CONF;
    let x;
    defpred P[Element of X] means x >><< $1;
A3: for y,z st y <==> z & P[y] holds P[z]
    proof
      let y,z;
      assume
B1:   y <==> z & P[y];
      consider u such that
B2:   x =*=> u & u <=*= y by B1,DEF2;
      per cases by B1;
      suppose
B3:     y ==> z;
        y =*=> z by B3,Th2; then
        u <<>> z by B2;
        hence P[z] by A1,B2,Lm5;
      end;
      suppose
B5:     y <== z;
        thus P[z] by B1,B5,Th2,Lm5;
      end;
    end;
    for y,z st y <=*=> z & P[y] holds P[z] from Star2(A3);
    hence thesis;
  end;
end;

definition
  let T be RelStr;
  attr T is Noetherian means
  :Def1:
  the InternalRel of T is co-well_founded;
end;

definition
  let T be TA-structure;
  attr T is consistent means
  :Def9:
  for t being type of T for a being
  adjective of T st a in adjs t holds not non-a in adjs t;
end;

:: scheme FuncRecursiveUniqu2
::   { X() -> non empty set, F(XFinSequence of X()) -> Element of X(),
::     F1,F2() -> sequence of  X()}:
::   F1() = F2()
::   provided
:: A1: for n being Nat holds F1().n = F(F1()|n) and
:: A2: for n being Nat holds F2().n = F(F2()|n)
:: proof
::   deffunc FX(set) = F(IFXFinSequence($1,X()));
::   reconsider f1=F1() as Function;
::   reconsider f2=F2() as Function;
:: A3: dom f1 = NAT & for n being Nat holds f1.n = FX(f1|n)
::   proof
::     thus dom f1 = NAT by FUNCT_2:def 1;
::     let n be Nat;
::     thus f1.n = F(F1()|n) by A1 .= FX(f1|n) by Def1;
::   end;
:: A4: dom f2 = NAT & for n being Nat holds f2.n = FX(f2|n)
::   proof
::     thus dom f2 = NAT by FUNCT_2:def 1;
::     let n be Nat;
::     thus f2.n = F(F2()|n) by A2 .= FX(f2|n) by Def1;
::   end;
::   f1 = f2 from FuncRecursiveUniq(A3,A4);
::   hence thesis;
:: end;