registration
  cluster CONF -> CR for ARS;
  coherence
  proof let X;
    assume
A10: X is CONF;
    let x;
    defpred P[Element of X] means x >><< $1;
A3: for y,z st y <==> z & P[y] holds P[z]
    proof
      let y,z;
      assume
B10:   y <==> z & P[y];
      consider u such that
B8:   x =*=> u & u <=*= y by B10,DEF2;
      per cases by B10;
      suppose
B3:     y ==> z;
        y =*=> z by B3,Th2; then
        u <<>> z by B8;
        hence P[z] by A10,B8,Lm5;
      end;
      suppose
B5:     y <== z;
        thus P[z] by B10,B5,Th2,Lm5;
      end;
    end;
    for y,z st y <=*=> z & P[y] holds P[z] from Star2(A3);
    hence thesis;
  end;
end;

definition
  let X,x be set;
  func IFXFinSequence(x,X) -> XFinSequence of X equals :Def1:
  x if x is XFinSequence of X
  otherwise <%>X;
  correctness;
end;

scheme
  MSSLambda { I() -> set, F(object) -> object }:
  ex f being ManySortedSet of I() st
  for i being set st i in I() holds f.i = F(i);
  consider f being Function such that
B3: dom f = I() and
B6: for i being object st i in I() holds f.i = F(i) from FUNCT_1:sch 3;
  reconsider f as ManySortedSet of I() by B3,PARTFUN1:def 2,RELAT_1:def 18;
  take f;
  thus thesis by B6;
end;


scheme FuncRecursiveUniqu2
  { X() -> non empty set, F(XFinSequence of X()) -> Element of X(),
    F1,F2() -> sequence of  X()}:
  F1() = F2()
  provided
A5: for n being Nat holds F1().n = F(F1()|n) and
A2: for n being Nat holds F2().n = F(F2()|n)
proof
  deffunc FX(set) = F(IFXFinSequence($1,X()));
  reconsider f1=F1() as Function;
  reconsider f2=F2() as Function;
A1: dom f1 = NAT & for n being Nat holds f1.n = FX(f1|n)
  proof
    thus dom f1 = NAT by FUNCT_2:def 1;
    let n be Nat;
    thus f1.n = F(F1()|n) by A5 .= FX(f1|n) by Def1;
  end;
A8: dom f2 = NAT & for n being Nat holds f2.n = FX(f2|n)
  proof
    thus dom f2 = NAT by FUNCT_2:def 1;
    let n be Nat;
    thus f2.n = F(F2()|n) by A2 .= FX(f2|n) by Def1;
  end;
  f1 = f2 from FuncRecursiveUniq(A1,A8);
  hence thesis;
end;